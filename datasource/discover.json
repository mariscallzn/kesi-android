{
  "featured": [
    {
      "id": "kesi-android-multi-module-podcast",
      "title": "Multi-Module Architecture Overview",
      "description": "In this podcast, you will hear how to modularized an app and the different strategies.",
      "img": "kesi-android-multi-module-podcast.jpg",
      "type": "Podcast"
    },
    {
      "id": "deep-dive-unveiling-kesi-android-podcast",
      "title": "Deep Dive: Unveiling Kesi Android",
      "description": "Welcome to the very first deep dive on this blog! Today, we're not just skimming the surface. We're jumping headfirst into the intricate world of Android development by dissecting a complete application: **Kesi Android**. Ever wondered what truly goes into building a robust, maintainable, and well-structured Android application? Beyond the UI and features, there's a hidden world of architectural decisions, best practices, and foundational setup that can make or break a project. This series is all about uncovering that world.",
      "img": "deep-dive-unveiling-kesi-android-podcast.jpg",
      "type": "Podcast"
    },
    {
      "id": "gradle-convention-plugins-podcast",
      "title": "Convention plugins explained",
      "description": "Think of convention plugins as reusable, opinionated blueprints for your Gradle build configurations. Instead of scattering compileSdk, minSdk, Kotlin options, Hilt setup, and common dependencies across every module's.",
      "img": "gradle-convention-plugins-podcast.jpg",
      "type": "Podcast"
    },
    {
      "id": "hilt-podcast",
      "title": "Podcast: Hilt for modern Android development",
      "description": "Hilt is built on top of Dagger and simplifies DI by providing a standard way to use Dagger in your Android applications. It's specifically designed for Android, reducing boilerplate, and integrating seamlessly with Jetpack libraries.",
      "img": "hilt-podcast.jpg",
      "type": "Podcast"
    },
    {
      "id": "solid-podcast",
      "title": "Podcast: SOLID Explained in the Jetpack compose world",
      "description": "Let's dive in and see how each SOLID principle shines in a Compose-centric world, turning your UIs from just \"working\" to \"wow-king\"!",
      "img": "solid-podcast.jpg",
      "type": "Podcast"
    },
    {
      "id": "mvi-podcast",
      "title": "Android UI Sanity: Decoding MVI with Compose and Kotlin Flows",
      "description": "MVI, when combined with the declarative power of Jetpack Compose and the reactive capabilities of Kotlin's",
      "img": "mvi-podcast.jpg",
      "type": "Podcast"
    }
  ],
  "promotedContent": [
    {
      "category": {
        "id": "kesi-android",
        "name": "Kesi Android"
      },
      "promotedContent": [
        {
          "id": "deep-dive-unveiling-kesi-android",
          "img": "deep-dive-unveiling-kesi-android.jpg",
          "type": "Article",
          "title": "Deep Dive: Unveiling Kesi Android",
          "description": "Welcome to the very first deep dive on this blog! Today, we're not just skimming the surface. We're jumping headfirst into the intricate world of Android development by dissecting a complete application: **Kesi Android**. Ever wondered what truly goes into building a robust, maintainable, and well-structured Android application? Beyond the UI and features, there's a hidden world of architectural decisions, best practices, and foundational setup that can make or break a project. This series is all about uncovering that world."
        },
        {
          "id": "kesi-android-multi-module",
          "img": "kesi-android-multi-module.jpg",
          "type": "Article",
          "title": "Kesi Android Multi-Module Architecture",
          "description": "In this post, I'll walk you through how Kesi Android divided its codebase into distinct modules to achieve a multi-module architecture. I'll explain the reasoning behind each module, and discuss how this approach helps us adhere to SOLID principles and significantly enhances project scalability."
        },
        {
          "id": "gradle-convention-plugins",
          "img": "gradle-convention-plugins.jpg",
          "type": "Article",
          "title": "Gradle convention plugins in Kesi Android",
          "description": "Ah, Gradle. The powerful, flexible, and sometimes overwhelmingly complex build system that powers our Android projects. If you've ever found yourself endlessly copying and pasting configurations across `build.gradle.kts` files, battling inconsistencies between modules, or dreading the thought of updating a common dependency everywhere, then this post is for you. This was certainly our reality at Kesi Android before we embraced a more structured approach."
        }
      ]
    },
    {
      "category": {
        "id": "architecture",
        "name": "Architecture"
      },
      "promotedContent": [
        {
          "id": "hilt",
          "img": "hilt.jpg",
          "type": "Article",
          "title": "Unlock Simpler Android Development: A Deep Dive into Hilt",
          "description": "Hey Android Devs! \uD83D\uDC4B Are you tired of wrestling with boilerplate code for dependency injection? Do you dream of a cleaner, more maintainable, and testable codebase? If you nodded yes (even a little!), then you're in the right place. Today, we're diving deep into **Hilt**, Google's recommended dependency injection framework for Android, and how it can revolutionize your development workflow."
        },
        {
          "id": "solid",
          "img": "solid.jpg",
          "type": "Article",
          "title": "SOLID in Jetpack Compose: Building Bulletproof Android UIs That Spark Joy",
          "description": "Hey Android devs! We're all riding the Jetpack Compose wave, and loving it, right? Declarative UIs, less boilerplate, and a more intuitive way to build beautiful apps."
        },
        {
          "id": "mvi",
          "img": "mvi.jpg",
          "type": "Article",
          "title": "MVI with Compose & SharedFlow: The Secret Sauce for Modern Android UIs",
          "description": "Are you tired of wrestling with unpredictable UI states, complex ViewModel logic, and testing nightmares? In the ever-evolving landscape of Android development, building robust, scalable, and maintainable UIs is paramount."
        }
      ]
    },
    {
      "category": {
        "id": "kotlin",
        "name": "Kotlin"
      },
      "promotedContent": [
        {
          "id": "kotlin-coroutines-compose",
          "title": "Mastering Kotlin Coroutines in Jetpack Compose",
          "description": "In the fast-paced world of Android development, building slick, responsive user interfaces is paramount. Users expect apps to be fluid, without janky animations or frozen screens, especially when data is being fetched or processed in the background.",
          "img": "kotlin-coroutines-compose.jpg",
          "type": "Article"
        },
        {
          "id": "kotlin-scoped-functions",
          "title": "Kotlin Scoped Functions: Unlock Cleaner, More Expressive Code!",
          "description": "Ever feel like your Kotlin code could be just a little bit tighter, a tad more readable? You're not alone! While Kotlin is already a beautifully concise language, there's a set of tools in its standard library that can elevate your code from good to great:",
          "img": "kotlin-scoped-functions.jpg",
          "type": "Article"
        },
        {
          "id": "kotlin-inline",
          "title": "Kotlin's Inline Secrets",
          "description": "By the end of this post, you'll not only understand what each of these keywords does but also how they beautifully interrelate. Let's demystify them!",
          "img": "kotlin-inline.jpg",
          "type": "Article"
        }
      ]
    }
  ]
}
