{
  "id": "kesi-android-multi-module",
  "title": "Kesi Android Multi-Module Architecture",
  "description": "In this post, I'll walk you through how Kesi Android divided its codebase into distinct modules to achieve a multi-module architecture. I'll explain the reasoning behind each module, and discuss how this approach helps us adhere to SOLID principles and significantly enhances project scalability.",
  "thumbnail": "kesi-android-multi-module.jpg",
  "content": [
    {
      "type": "paragraph",
      "content": "Hello everyone! In this post, I'll walk you through how Kesi Android divided its codebase into distinct modules to achieve a multi-module architecture. I'll explain the reasoning behind each module, and discuss how this approach helps us adhere to SOLID principles and significantly enhances project scalability. Let's dive right into it!"
    },
    {
      "type": "bullet_list",
      "content": "At the root level of Kesi Android, I've structured the project with the following key modules:",
      "bulletPoints": [
        "app",
        "core",
        "data",
        "domain",
        "feature",
        "testing"
      ]
    },
    {
      "type": "sub_header",
      "content": "App"
    },
    {
      "type": "paragraph",
      "content": "In an Android app using a multi-module architecture, the :app module serves as the primary entry point and the orchestrator of the application. It's the module that ultimately gets compiled into the runnable APK (Android Package Kit) or AAB (Android App Bundle) that users install."
    },
    {
      "type": "paragraph",
      "content": "Think of it as the main assembly point. Here's a breakdown of its key responsibilities and characteristics:"
    },
    {
      "type": "bullet_list",
      "content": "",
      "bulletPoints": [
        "Application Entry Point: It contains the Application class, MainActivity (or other entry activities), and the AndroidManifest.xml that defines the application's components and permissions.",
        "Dependency Aggregation: The :app module depends on various feature modules (which we will talk about them later), core and data modules. It brings together these independent pieces to form the complete application.",
        "Navigation Host: It manages the top-level navigation graph, coordinating transitions between different features. While individual features manage their internal navigation, the :app module handles navigation between features.",
        "Initialization of Global Services: Application-wide services and libraries (like dependency injection frameworks, analytics, logging) are initialized within the :app module's Application class.",
        "Build Configuration Hub: It's where I defined application-level build configurations, such as buildConfigField and signing configurations. It can also manage different build variants: debug and release."
      ]
    },
    {
      "type": "paragraph",
      "content": "In essence, the :app module acts like the \"conductor\" of an orchestra, ensuring all the individual \"musicians\" (feature and core modules) play together harmoniously to deliver the final \"symphony\" (the application). This separation helps in achieving better code organization, faster build times (by only rebuilding changed modules), and improved scalability for larger projects."
    },
    {
      "type": "sub_header",
      "content": "Core"
    },
    {
      "type": "paragraph",
      "content": "The core module acts as a parent directory. It groups together several sub-modules that provide essential, foundational functionalities for the entire Kesi Android application. These sub-modules include:"
    },
    {
      "type": "bullet_list",
      "content": "",
      "bulletPoints": [
        ":core:app",
        ":core:model",
        ":core:uisystem"
      ]
    },
    {
      "type": "paragraph",
      "content": "The :core:app module serves as a foundational library defining abstractions and contracts for core application-wide functionalities that are needed across various parts of the application, including feature modules. It dictates what essential services should do, not how they do it."
    },
    {
      "type": "paragraph",
      "content": "The :core:model module is responsible for defining the domain models and data structures that represent the core business logic and data of Kesi Android. It's the single source of truth for the application's data."
    },
    {
      "type": "paragraph",
      "content": "The :core:uisystem module encapsulates foundational UI elements, themes, styling, base UI components, and UI-related utilities that are shared across multiple feature modules to ensure a consistent look and feel."
    },
    {
      "type": "sub_header",
      "content": "Data"
    },
    {
      "type": "paragraph",
      "content": "The data module, similar to core, acts as a parent directory. It groups together several sub-modules that provide a good way to structure the data layer, focusing on abstracting away the concrete implementations of data sources. These sub-modules include:"
    },
    {
      "type": "bullet_list",
      "content": "",
      "bulletPoints": [
        ":data:api",
        ":data:repository",
        ":data:retrofit",
        ":data:datastore"
      ]
    },
    {
      "type": "paragraph",
      "content": "The :data:api module serves as the central contract or abstraction layer for all data operations in your application. It defines what data can be fetched or manipulated and what operations are available, but not how these operations are implemented or where the data comes from. All other modules that need to interact with data (like feature modules or use cases) will depend solely on this module for their data-related interfaces, promoting loose coupling and making it easier to swap data source implementations without affecting the rest of the app."
    },
    {
      "type": "paragraph",
      "content": "The :data:repository module is responsible for defining the data access contracts (repository interfaces) for the application's domain and providing their concrete implementations. These implementations act as the single source of truth for specific domain data, coordinating operations between different underlying data sources (e.g., remote network API, local database, in-memory cache). It encapsulates the logic of how and where to fetch or store data."
    },
    {
      "type": "paragraph",
      "content": "The :data:retrofit module contains the concrete implementation for making network API calls using the Retrofit library. It provides the actual networking logic that fulfills the contracts defined by the Retrofit service interfaces in :data:api"
    },
    {
      "type": "paragraph",
      "content": "The :data:datastore module contains the concrete implementation for storing and retrieving data using Jetpack DataStore. It implements the relevant data source abstractions defined in :data:api"
    },
    {
      "type": "sub_header",
      "content": "Domain"
    },
    {
      "type": "paragraph",
      "content": "The :domain module represents the core business logic and rules of your application. It defines what your application does at a high level, without specifying how it's presented to the user or how data is stored or retrieved. This module is a pure Kotlin module, with no dependencies on the Android framework or any specific external libraries (like networking or database libraries)."
    },
    {
      "type": "sub_header",
      "content": "Feature"
    },
    {
      "type": "paragraph",
      "content": "A feature module is a self-contained unit that groups all the code, resources, and logic related to a specific feature or user flow of the application. It aims to be as independent as possible from other feature modules to promote modularity, parallel development, and potentially dynamic delivery."
    },
    {
      "type": "paragraph",
      "content": "Kesi Android at the moment offers:"
    },
    {
      "type": "bullet_list",
      "content": "",
      "bulletPoints": [
        ":feature:article: Displays individual blog posts, including the one you're currently reading.",
        ":feature:articles: Presents a list of all available blog posts.",
        ":feature:audioplayer: Provides functionality to listen to AI-generated audio summaries of posts.",
        ":feature:discover: Serves as the main landing screen or discovery hub for Kesi Android content."
      ]
    },
    {
      "type": "sub_header",
      "content": "Testing"
    },
    {
      "type": "paragraph",
      "content": "The testing module serves as a centralized hub for our testing infrastructure. This is where I host all the test doubles (like mocks or fakes) for our abstractions and provide common test data. Furthermore, this module declares dependencies on all the necessary testing libraries (e.g., JUnit, Mockito, Espresso). It's designed to be included by other modules primarily using Gradle's testImplementation or androidTestImplementation configurations, ensuring that testing utilities don't leak into the production app code."
    },
    {
      "type": "sub_header",
      "content": "Convention plugins"
    },
    {
      "type": "paragraph",
      "content": "So, that's the rundown of Kesi Android's module structure as of version 1.0.3! While this organization brings many benefits, managing dependencies and versions across all these modules can quickly become a huge pain in the neck if not handled correctly."
    },
    {
      "type": "paragraph",
      "content": "Don't worry, I won't leave you hanging! In an upcoming post, I'll dive into how I maintain consistency for libraries and plugins across all modules using convention plugins. We'll also explore how modern Android development leverages version catalogs (those handy .toml files) to streamline this entire process. Stay tuned for that deep dive!"
    }
  ],
  "podcast": {
    "id": "kesi-android-multi-module-podcast",
    "title": "Multi-Module Architecture Overview",
    "audio": "kesi-android-multi-module-podcast-podcast.wav",
    "img": "kesi-android-multi-module-podcast.jpg"
  }
}